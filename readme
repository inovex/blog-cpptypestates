This code implements the example from
https://docs.rust-embedded.org/book/static-guarantees/design-contracts.html#type-states
in modern C++ 17.
Note that the original is quite sloppy, as it doesn't define the interface for
the generated GPIO configuration.

Notes:

* The Rust version encodes the state, direction and mode twice, once in the type
  and once in the struct members. The C++ version only uses the type to convey
  that information, because having both it redundant and the point of this ex-
  ample is to provide a type-safe wrapper.
* The Rust version depends directly on the struct generated by svd2rust. Since
  that prevents the reuse of the type-safe wrapper, the C++ version uses a
  pointer to an interface instead, which corresponds to the use of a boxed types
  in Rust.

FAQ:

* Isn't the Template-Meta-Programming stuff completely unreadable?
  * Yeah, but this is a library, and its usage is relatively straightforward.
    And everybody in the C++ space loves to use boost anyway, which is exactly
    the same, if not worse.
* Doesn't make the Template-Meta-Programming stuff the compile-times really bad?
  * Yeah, right, but we're competing with Rust here, so we should be just fine.
* It's header-only, so everything is recompiled on every change.
  * Have you looked at how Rust compilation works? It's exactly the same! Of
    course you can split it into different modules, but in C++ you can isolate
    compilation units too.
* Isn't it painful to write all this template code?
  * It's no fun fighting the borrow-checker either. You get used to it, either
    way.
